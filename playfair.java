
import javax.swing.JOptionPane;

/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */

/**
 *
 * @author ADMIN
 */
public class NewJFrame extends javax.swing.JFrame {

    /**
     * Creates new form NewJFrame
     */
    public NewJFrame() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea2 = new javax.swing.JTextArea();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea3 = new javax.swing.JTextArea();
        jTextField1 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jTextField3 = new javax.swing.JTextField();
        jButton3 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTextArea5 = new javax.swing.JTextArea();

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("PlayFair");

        jTextArea2.setColumns(20);
        jTextArea2.setRows(5);
        jScrollPane2.setViewportView(jTextArea2);

        jTextArea3.setColumns(20);
        jTextArea3.setRows(5);
        jScrollPane3.setViewportView(jTextArea3);

        jButton1.setText("Generate key");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setText("Encryption");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Decryption");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jLabel1.setText("key");

        jLabel3.setText("key");

        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jScrollPane4.setViewportView(jTextArea4);

        jTextArea5.setColumns(20);
        jTextArea5.setRows(5);
        jScrollPane5.setViewportView(jTextArea5);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 291, Short.MAX_VALUE)
                    .addComponent(jScrollPane3))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addGroup(layout.createSequentialGroup()
                                            .addGap(20, 20, 20)
                                            .addComponent(jButton1)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jButton2))
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jTextField1))
                                        .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                            .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, 175, javax.swing.GroupLayout.PREFERRED_SIZE))))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap(27, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(85, 85, 85)
                        .addComponent(jButton3)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel1)
                            .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(4, 4, 4)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton1)
                            .addComponent(jButton2)))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(14, 14, 14)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 147, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jTextField3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addGap(18, 18, 18)
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(13, 13, 13)
                        .addComponent(jButton3))
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 145, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(17, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>                        

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
   

    // Tạo khóa khi nhấn nút
    String userInputKey = jTextField1.getText().toLowerCase(); // Lấy đầu vào từ người dùng
    StringBuilder key = new StringBuilder(userInputKey);
    boolean[] used = new boolean[26];
    String alphabet = "abcdefghijklmnopqrstuvwxyz";

    for (char c : userInputKey.toCharArray()) {
        int index = c - 'a'; 
        if (index >= 0 && index < 26) {
            used[index] = true; 
        }
    }

    for (int i = 0; i < alphabet.length(); i++) {
        if (!used[i]) { 
            key.append(alphabet.charAt(i)); 
        }
    }

    jTextArea4.setText(key.toString());
    
    // Tạo ma trận Playfair
    generateMatrix(); // Thêm dòng này để tạo ma trận

    }                                        

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:
   
    // Xử lý mã hóa khi nhấn nút
    String plainText = jTextArea2.getText().toLowerCase(); // Chuyển đổi văn bản gốc thành chữ thường
    String keyInput = jTextField1.getText().toLowerCase(); // Chuyển đổi khóa thành chữ thường
    
    if (plainText.isEmpty() || keyInput.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Vui lòng nhập văn bản gốc và khóa!", "Lỗi", JOptionPane.ERROR_MESSAGE);
        return;
    }

    // Đảm bảo rằng ma trận được tạo trước khi mã hóa
    generateMatrix(); // Đảm bảo ma trận được tạo dựa trên khóa
    
    String encryptedText = encrypt(plainText); // Mã hóa văn bản gốc
    jTextArea3.setText(encryptedText); // Hiển thị văn bản đã mã hóa


    }                                        

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {                                         
        // TODO add your handling code here:                                                                                                                                                              
                                                                           

    // Lấy khóa từ text field 3 và chuyển thành chữ thường
    String keyInput = jTextField3.getText().toLowerCase();

    // Kiểm tra nếu người dùng không nhập khóa thì thông báo lỗi
    if (keyInput.isEmpty()) {
        JOptionPane.showMessageDialog(this, "Vui lòng nhập khóa!", "Lỗi", JOptionPane.ERROR_MESSAGE);
        return; // Thoát ra nếu không có khóa
    }

    // Gọi hàm tạo ma trận Playfair dựa trên khóa vừa nhập
    generateMatrixFromKey(keyInput);

    // Gọi hàm lấy chuỗi số tương ứng với ma trận và hiển thị vào jTextArea5
    String keyNumberSequence = getNumberSequenceFromMatrix();
    jTextArea5.setText(keyNumberSequence); // Hiện dãy số tương ứng với ma trận (nếu cần)

    // Lấy văn bản gốc từ jTextArea2 để mã hóa
    String plainText = jTextArea2.getText().toLowerCase(); // Lấy input từ jTextArea2

    // Nếu có văn bản trong jTextArea2
    if (!plainText.isEmpty()) {
        // Gọi hàm mã hóa văn bản
        String decryptedText = decrypt(plainText); // Mã hóa văn bản gốc
       
        // Gọi hàm giải mã văn bản ngay sau khi mã hóa
        //String decryptedText = decrypt(encryptedText); // Giải mã văn bản đã mã hóa

        // Hiển thị văn bản đã giải mã vào jTextArea3 dưới dạng chữ thường
        jTextArea3.setText(decryptedText.toLowerCase()); // Hiện kết quả giải mã
    } else {
        // Nếu không có văn bản để mã hóa, thông báo cho người dùng
        JOptionPane.showMessageDialog(this, "Không có văn bản để mã hóa!", "Thông báo", JOptionPane.INFORMATION_MESSAGE);
    }


    
    }                                        

    private void generateMatrixFromKey(String keyInput) {
    StringBuilder uniqueKey = new StringBuilder(); // Chuỗi để lưu khóa duy nhất
    boolean[] used = new boolean[26]; // Mảng kiểm tra xem ký tự đã được dùng chưa
    key = keyInput.toUpperCase().replace("J", "I"); // Chuyển khóa thành chữ in hoa và thay thế 'J' bằng 'I'

    // Thêm các ký tự từ khóa vào uniqueKey nếu ký tự chưa được sử dụng
    for (char c : key.toCharArray()) { // Duyệt từng ký tự trong khóa
        if (c >= 'A' && c <= 'Z' && !used[c - 'A']) { // Nếu là ký tự hợp lệ và chưa dùng
            uniqueKey.append(c); // Thêm vào uniqueKey
            used[c - 'A'] = true; // Đánh dấu ký tự đã được sử dụng
        }
    }

    // Thêm các ký tự chưa được dùng (A-Z, trừ J) vào uniqueKey
    for (char c = 'A'; c <= 'Z'; c++) { 
        if (c == 'J') continue; // Bỏ qua ký tự 'J'
        if (!used[c - 'A']) { // Nếu ký tự chưa được dùng
            uniqueKey.append(c); // Thêm ký tự vào uniqueKey
        }
    }

    // Tạo ma trận 5x5 từ chuỗi uniqueKey
    matrix = new char[5][5]; // Khởi tạo ma trận 5x5
    for (int i = 0; i < 5; i++) { // Duyệt qua từng hàng của ma trận
        for (int j = 0; j < 5; j++) { // Duyệt qua từng cột của ma trận
            matrix[i][j] = uniqueKey.charAt(i * 5 + j); // Gán ký tự từ uniqueKey vào vị trí tương ứng
        }
    }
}

// Hàm tạo chuỗi số tương ứng từ ma trận Playfair để hiển thị
// Hàm tạo chuỗi ký tự từ ma trận Playfair để hiển thị (chữ thường)
private String getNumberSequenceFromMatrix() {
    StringBuilder sequence = new StringBuilder(); // Chuỗi để lưu các ký tự
    for (int i = 0; i < 5; i++) { // Duyệt qua từng hàng của ma trận
        for (int j = 0; j < 5; j++) { // Duyệt qua từng cột của ma trận
            sequence.append(Character.toLowerCase(matrix[i][j])); // Thêm ký tự vào chuỗi (ở dạng chữ thường)
        }
    }
    return sequence.toString(); // Trả về chuỗi ký tự
}

  
    private String key; // Khóa mã hóa
    private char[][] matrix; // Ma trận 5x5 cho thuật toán Playfair
    private void generateMatrix() { // Hàm tạo ma trận 5x5 từ khóa
        StringBuilder uniqueKey = new StringBuilder(); // StringBuilder để lưu khóa duy nhất
        boolean[] used = new boolean[26]; // Mảng boolean để kiểm tra ký tự đã được sử dụng chưa
        key = jTextField1.getText().toUpperCase().replace("J", "I"); // Lấy khóa từ text field, chuyển thành chữ hoa và thay J bằng I
        for (char c : key.toCharArray()) { // Duyệt qua từng ký tự trong khóa
            if (c >= 'A' && c <= 'Z' && !used[c - 'A']) { // Kiểm tra nếu ký tự là chữ cái và chưa được sử dụng
                uniqueKey.append(c); // Thêm ký tự vào khóa duy nhất
                used[c - 'A'] = true; // Đánh dấu ký tự là đã sử dụng
            }
        }

        // Thêm các ký tự còn lại vào khóa
        for (char c = 'A'; c <= 'Z'; c++) { // Duyệt qua các ký tự từ A đến Z
            if (c == 'J') continue; // Bỏ qua ký tự J
            if (!used[c - 'A']) { // Nếu ký tự chưa được sử dụng
                uniqueKey.append(c); // Thêm ký tự vào khóa duy nhất
            }
        }

        // Tạo ma trận 5x5 từ khóa
        matrix = new char[5][5]; // Khởi tạo ma trận 5x5
        for (int i = 0; i < 5; i++) { // Duyệt qua các hàng
            for (int j = 0; j < 5; j++) { // Duyệt qua các cột
                matrix[i][j] = uniqueKey.charAt(i * 5 + j); // Gán ký tự vào ma trận
            }
        }
    }

    private String prepareText(String text) { // Hàm chuẩn hóa văn bản đầu vào
        text = text.toUpperCase().replace("J", "I").replaceAll("[^A-Z]", ""); // Chuyển sang chữ hoa, thay J bằng I và loại bỏ ký tự không phải chữ cái
        StringBuilder sb = new StringBuilder(); // StringBuilder để lưu văn bản đã chuẩn hóa

        for (int i = 0; i < text.length(); i++) { // Duyệt qua từng ký tự trong văn bản
            char current = text.charAt(i); // Lấy ký tự hiện tại
            sb.append(current); // Thêm ký tự vào StringBuilder
            if (i < text.length() - 1 && current == text.charAt(i + 1)) { // Nếu ký tự hiện tại giống ký tự tiếp theo
                sb.append('X'); // Thêm ký tự 'X' giữa hai ký tự giống nhau
            }
        }

        if (sb.length() % 2 != 0) { // Nếu độ dài văn bản là lẻ
            sb.append('X'); // Thêm 'X' vào cuối
        }

        return sb.toString(); // Trả về văn bản đã chuẩn hóa
    }

    private String encodePair(char a, char b) { // Hàm mã hóa một cặp ký tự
        int row1 = 0, col1 = 0, row2 = 0, col2 = 0; // Khởi tạo biến lưu vị trí của các ký tự

        // Tìm vị trí của ký tự trong ma trận
        for (int i = 0; i < 5; i++) { // Duyệt qua các hàng
            for (int j = 0; j < 5; j++) { // Duyệt qua các cột
                if (matrix[i][j] == a) { // Nếu ký tự a được tìm thấy
                    row1 = i; // Lưu hàng
                    col1 = j; // Lưu cột
                }
                if (matrix[i][j] == b) { // Nếu ký tự b được tìm thấy
                    row2 = i; // Lưu hàng
                    col2 = j; // Lưu cột
                }
            }
        }

        // Mã hóa theo quy tắc Playfair
        if (row1 == row2) { // Nếu hai ký tự ở cùng hàng
            return "" + matrix[row1][(col1 + 1) % 5] + matrix[row2][(col2 + 1) % 5]; // Chuyển sang ký tự bên phải
        } else if (col1 == col2) { // Nếu hai ký tự ở cùng cột
            return "" + matrix[(row1 + 1) % 5][col1] + matrix[(row2 + 1) % 5][col2]; // Chuyển xuống ký tự bên dưới
        } else { // Nếu hai ký tự ở khác hàng và cột
            return "" + matrix[row1][col2] + matrix[row2][col1]; // Tạo ký tự từ hàng của ký tự đầu tiên và cột của ký tự thứ hai
        }
    }

    public String encrypt(String text) {
    String preparedText = prepareText(text); // Chuẩn hóa văn bản đầu vào
    StringBuilder encrypted = new StringBuilder(); // StringBuilder để lưu kết quả mã hóa

    for (int i = 0; i < preparedText.length(); i += 2) {
        char a = preparedText.charAt(i);
        char b = preparedText.charAt(i + 1);
        encrypted.append(encodePair(a, b)); // Mã hóa cặp ký tự và thêm vào kết quả
    }

    return encrypted.toString().toLowerCase(); // Chuyển đổi kết quả mã hóa thành chữ thường
}

   
    


// giải mã
    
    
public String decrypt(String text) {
    String preparedText = prepareText(text); // Chuẩn hóa văn bản đầu vào
    StringBuilder decrypted = new StringBuilder(); // Tạo một StringBuilder để lưu trữ văn bản đã giải mã 

    // Duyệt qua văn bản đã chuẩn hóa theo cặp ký tự
    for (int i = 0; i < preparedText.length(); i += 2) { 
        char a = preparedText.charAt(i); // Lấy ký tự đầu tiên của cặp
        char b = preparedText.charAt(i + 1); // Lấy ký tự thứ hai của cặp
        decrypted.append(decodePair(a, b)); // Giải mã cặp ký tự và thêm vào kết quả
    }

    return decrypted.toString().toLowerCase(); // Chuyển đổi kết quả thành chữ thường trước khi trả về
}


// Giải mã theo quy tắc Playfair
private String decodePair(char a, char b) {
    // Tìm vị trí của ký tự trong ma trận
    int row1 = 0, col1 = 0, row2 = 0, col2 = 0;

    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            if (matrix[i][j] == a) {
                row1 = i;
                col1 = j;
            }
            if (matrix[i][j] == b) {
                row2 = i;
                col2 = j;
            }
        }
    }

    // Giải mã theo quy tắc Playfair
    if (row1 == row2) { // Nếu hai ký tự ở cùng hàng
        return "" + matrix[row1][(col1 - 1 + 5) % 5] + matrix[row2][(col2 - 1 + 5) % 5]; // Chuyển sang ký tự bên trái
    } else if (col1 == col2) { // Nếu hai ký tự ở cùng cột
        return "" + matrix[(row1 - 1 + 5) % 5][col1] + matrix[(row2 - 1 + 5) % 5][col2]; // Chuyển lên ký tự bên trên
    } else { // Nếu hai ký tự ở khác hàng và cột
        return "" + matrix[row1][col2] + matrix[row2][col1]; // Tạo ký tự từ hàng của ký tự đầu tiên và cột của ký tự thứ hai
    }
}




    
  /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(NewJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new NewJFrame().setVisible(true);
            }
        });
    }
    
    

    

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea jTextArea2;
    private javax.swing.JTextArea jTextArea3;
    private javax.swing.JTextArea jTextArea4;
    private javax.swing.JTextArea jTextArea5;
    private javax.swing.JTextField jTextField1;
    private javax.swing.JTextField jTextField3;
    // End of variables declaration                   
}
